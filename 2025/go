## start go

1. https://go.dev/    에서 go 설치

2. 폴더 생성 후 파일 생성

    파일명.go 생성

3. 파일을 실행하기 위해서는 모둘 설치 필요

  실행할 파일이 있는 폴더로 이동 후
  go mod init 모둘명 입력     ---    모둘명은 폴더 경로로 지정하는 것이 좋음.   ex) goprojects/hello

4. 모둘 설치했으면 

    go build 입력

5. 파일을 실행하려면

  go run 파일명.go     or    ./파일명.exe     입력


========================================================================================================================================================================

## go의 기초

package main              //  시작은 항상 package로 시작

import "fmt"              //  fmt : package 중 하니

func main() {             //  func : function의 약자
	fmt.Println("Hello Go World")
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

변수

package main

import "fmt"

func main() {
	var a int = 3
	var b int            // int의 기본값은 0
	var c = 4
	d := 5
	var e = "Hello"
	f := 3.14

	fmt.Println(a, b, c, d, e, f)
}


출력 -> 3 0 4 5 Hello 3.14




** 연산의 각 항목의 타입은 같아야 한다.

func main() {
	a := 3                 // int - 64 bit = int64
	var b float64 = 3.5

	var c int = int(b)     // 3.5 -> 3
	d := float64(a) * b

	var e int64 = 7
	f := a * int(e)        // int와 int64는 다른 타입임

	fmt.Println(a, b, c, d, e, f)
}


출력 -> 3 3.5 3 10.5 7 21


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

입출력

package main

import (                                  // 여러개 임포트 할 때는 괄호로 묶어서
	"bufio"
	"fmt"
	"os"
)

func main() {
	stdin := bufio.NewReader(os.Stdin)      // 입력을 buffer로 감싸 빠른 Reader를 만들어 주는 코드.
                                          //  ->  입력을 줄 단위·문자 단위로 쉽게 읽고 남은 입력을 비울 때 유용함
	var a int
	var b int

	n, err := fmt.Scanln(&a, &b)
	if err != nil {                         // nil    =>    undefined, null 이런느낌
		fmt.Println(err)
		stdin.ReadString('\n')                // 잘못된 입력이 들어오면 그 줄을 통째로 clean 
	} else {
		fmt.Println(n, a, b)                  // n이 2로 출력되는 이유는 a, b 총 두 개의 값이 정상적으로 입력되었기 때문
	}

	n, err = fmt.Scanln(&a, &b)
	if err != nil {
		fmt.Println(err)
		stdin.ReadString('\n')
	} else {
		fmt.Println(a, b)
	}
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

배열

package main

func main() {
	var a = [2][3]int{
		{1, 2, 3},
		{4, 5, 6},			// 끝에 콤마 붙여야됨.
	}
	println(a[1][2])		// a의 1번째 줄에 2번째 요소
}

출력  ->  6

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

부분 슬라이스

package main

import "fmt"

func main() {
	s := []int{0, 1, 2, 3, 4, 5}
	s = s[2:5]			//  [ 첫 인덱스 , 마지막 인덱스 ]  	** 마지막 인덱스는 +1		---		출력 -> {2 3 4}
	s = s[1:]			//  [ 첫 인덱스 : ]  :  첫 인덱스부터 마지막까지 출력 				---		현재 s = {2 3 4} 니까 인덱스 1부터 끝까지 출력하면 {3 4}가 나옴
	fmt.Println(s)
}

출력 ->  {3 4}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

&(앰퍼샌드) 	:	포인터 주소를 반환하라는 의미

a := 10		:	a의 값은 10								a  출력 ->	10
&a			:	a의 주소를 가져와라						&a 출력 ->	0xc000018058
p := &a		:	p는 a의 주소를 가진 포인터				p  출력 ->	0xc000018058
*p			:	그 주소로 가서 실제 값을 가져와라			*p 출력 ->	10

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

append		:	새로운 요소가 추가된 새 슬라이드를 반환

ex)
		s := []int{0, 1}
		s = append(s, 2)		//	{0, 1, 2}
		s = append(s, 3, 4, 5)	// 	{0, 1, 2, 3, 4, 5}

		t := []int{6, 7}
		s = append(s, t...)		//	{0, 1, 2, 3, 4, 5, 6, 7}


***** append로 삭제 기능 구현하기

slice = append(slice[:i], slice[i+1:]...)		---		삭제할 요소의 인덱스 => i, 	---		:i =>  i의 앞 요소들		i+1:  =>  i의 뒷 요소들		

->	삭제할 요소의 앞부분과 뒷부분을 이어붙임.

ex) todos[1, 2, 3, 4, 5 ] 에서  3을 삭제한다면,
	i = 2 니까, 
	todos [:2]  	==		[1, 2]
	todos [3:]		==		[4, 5]
	append(todos[:2], todos[3:]...)		==		[1, 2, 4, 5]

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

for ... range 	:	반복문. 	---	항상 두 개의 값을 반환한다	(인덱스, 값)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_		:	무시

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

func NewRepository()		:		export deport 비슷한 개념 		---		외부에서 사용하기 위함임

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

net/http	:	Go 언어의 표준 라이브러리 	---		HTTP 통신을 처리하는 가장 근본적인 기능 제공    ---   Servlet API / Tomcat 와 비슷한 개념		---		사용법 : import "net/http" 

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

make(a, b) 		:		참조 타입을 사용 가능하게 만드는 함수
a	: 	타입
b 	:	용량 , 버퍼 크기

참조 타입 		:		slice, map, channel 등

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

map 	: 	key -> value 형태로 저장되는 자료구조


package main

import "fmt"

func main() {
	var m map[int]string

	m = make(map[int]string)
	m[901] = "Apple"
	m[134] = "Grape"
	m[777] = "Tomato"

	str := m[134]
	fmt.Println(str)	// Grape

	noData := m[999]	// 999는 없음
	fmt.Println(noData)	// 아무것도 안뜸

	delete(m, 777)		// 777 삭제

	fmt.Println(m)		// map[134:Grape 901:Apple]
}

출력 ->		Grape
	
			map[134:Grape 901:Apple]

************* map 키 체크 **************
	val, exists := m["901"]
	if !exists {
		fmt.Println("No 901 m")
	}
	fmt.Println(val)

출력 ->  Apple
****************************************

********** for 루프를 사용한 Map 열거 **************

	for key, val := range m {
		fmt.Println(key, val)
	}

출력 ->  	901 Apple
			134 Grape
			777 Tomato

***************************************************

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

gin		:	net/http 기반으로 만들어진 경량 프레임워크		---		API 개발 편의성을 극대화		---		@RestController / @GetMapping 와 비슷한 기능		---		사용법 : import "github.com/gin-gomic/gin" 			  ||| 			초기화된 프로젝트에서 진행.	  터미널 : go get -u github.com/gin-gonic/gin

gin.H	:	map과 같은 기능. JSON을 쉽게 만들 수 있음

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

strconv		:	문자열을 숫자로 변환하거나, 숫자를 문자열로 변환할 때 사용하는 패키지	---		사용법 : import "strconv" 

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

(배열)		var a = [...]int{1, 2, 3}		//  배열의 크기를 자동으로 지정해줌. 배열 크기 고정.			---			정석 :	var a = [3]int{1, 2, 3}
(슬라이스)	var a = []int{1, 2, 3}			//  슬라이스 크기 유연함.										---			[...] 안됨.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

make([]int, 5, 6)		:		길이 = 5, 용량 = 6 이라는 뜻.

package main

import "fmt"

func main() {
	sliceA := make([]int, 0, 3)

	for i := 1; i <= 12; i++ {
		sliceA = append(sliceA, i)		

		fmt.Println(len(sliceA), cap(sliceA))
	}

	fmt.Println(sliceA)
}

cap(sliceA)			:		1~3까지는 기존의 용량 3을 사용하고, 4~6까지는 용량 6을, 7~12는 용량 12의 슬라이스가 사용

출력  ->  1 3
2 3
3 3
4 6
5 6
6 6
7 12
8 12
9 12
10 12
11 12
12 12
[1 2 3 4 5 6 7 8 9 10 11 12]

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

copy(target, source)		:		앞에서부터 source의 요소를 target에 덮어쓴다. 길이는 둘 중 더 짧은 값만큼 복사.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

인터페이스

package main

import (
	"fmt"
	"math"
)

type Shape interface {				// 타입 상관없이 바로 사용가
	area() float64
	perimeter() float64
}

type Rect struct {
	width, height float64
}
type Circle struct {
	radius float64
}

func (r Rect) area() float64 {
	return r.width * r.height
}
func (r Rect) perimeter() float64 {
	return 2 * (r.width + r.height)
}

func (c Circle) area() float64 {
	return math.Pi * c.radius * c.radius
}
func (c Circle) perimeter() float64 {
	return 2 * math.Pi * c.radius
}

func main() {
	r := Rect{10, 20}
	c := Circle{10}

	showArea(r, c)
}

func showArea(shapes ...Shape) {
	for _, s := range shapes {
		a := s.area()
		fmt.Println(a)
	}
}

인터페이스 없으면 타입 하나 늘 때마다 함수가 갈아엎어짐.
인터페이스를 쓰면 '동작(area)'만 맞추면 자동으로 확장됨.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

fmt → 화면 출력/문자열 처리					ex)		fmt.Println("hello")
math → 수학 관련								ex)		math.Sqrt(9)  // 제곱근  -> 3,      math.Pi	 // 상수
time → 시간 관련								ex)		time.Now()
os → 파일·폴더·환경변수 등 운영체제 기능		ex)		os.Open("test.txt")
log → 콘솔에 로그 출력						ex)		log.Fatal("error")

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

defer 		:		함수가 끝나기 직전에 실행해라									---		무조건 마지막에 실행됨
panic		:		함수를 즉시 종료시키는 에러									---		panic이 발생하면 그 함수는 즉시 종료되고, 호출한 함수로 전파됨
recover		:		panic 상태를 제거하고 다음 문장을 호출							---		defer 안에서만 동작

package main

import (
	"fmt"
	"os"
)

func main() {
	println("start")
	openFile("Invalid.txt")

	println("Done")
}

func openFile(fn string) {
	defer func() {
		if r := recover(); r != nil {				// r  	:	 panic이 보낸 err
			fmt.Println("OPEN ERROR", r)
		}
	}()

	f, err := os.Open(fn)
	if err != nil {
		panic(err)									// 여기에 전달된 err가 recover()에 들어감
	}
	defer f.Close()
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
go 루틴

package main

import (
	"fmt"
	"time"
)

func say(s string) {
	for i := 0; i < 10; i++ {
		fmt.Println(s, "***", i)
	}
}

func main() {
	say("Sync")

	go say("Async1")
	go say("Async2")
	go say("Async3")

	time.Sleep(time.Second * 10)			// 10초 딜레이
}

go 사용 x 	 	-> 		하나씩 순서대로 실행.
go 사용			->		동시에 실행.

say(Sync)가 출력된 뒤에 go가 붙어있는 say들은 3개가 동시에 실행됨.
=>		무작위로 출력되는 현상 발생
ex)		
		Sync *** 0
		Sync *** 1
		Sync *** 2
			:
		Sync *** 9
		Async1 *** 0
		Async3 *** 0
		Async1 *** 1
		Async2 *** 0
		Async1 *** 2
		Async1 *** 3
		Async3 *** 1
		Async2 *** 1
			:
		Async2 *** 9
		Async1 *** 9
		Async3 *** 9

사용 예 )	파일 100개를 동시에 다운로드, 카메라 20개 상태를 동시에 체크, 5개 api를 동시에 호출, 대용량 이미지 처리
			->   	한 번에 한 작업만 하면 너무 느린 작업들, 독립적으로 동시에 처리하면 더 빠르거나 자연스러운 작업들을 처리할 때 사용.

package main

import (
	"fmt"
	"sync"
)

func main() {
	var wait sync.WaitGroup 	// go 루틴들이 끝날 때까지 기다리는 역할
	wait.Add(2)             	// 몇개의 go루틴을 기다릴 것인지

	go func() {
		defer wait.Done()
		fmt.Println("Hello")
	}()

	go func(msg string) {
		defer wait.Done()
		fmt.Println(msg)
	}("Hi")

	wait.Wait()
}

go 가 main과 함께 실행하기 때문에 main이 끝나기 전에 go를 기다리는 WaitGroup 사용

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ioutil 지원이 안되므로 ioutil이 대체된 위치 정리

ioutil.ReadFile		 ->		os.ReadFile
ioutil.WriteFile	 ->		os.WriteFile
ioutil.ReadAll		 ->		io.ReadAll
ioutil.NopCloser	 ->		io.NopCloser
ioutil.TempDir		 ->		os.MkdirTemp
ioutil.TempFile		 ->	 	os.CreateTemp

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

JSON		:		{
						"name": "Alex",
						"age": 10
					}

import "encoding/json"

인코딩		:		GO데이터 	-> 	JSON			---			json.Marchal()
디코딩		:		JSON 	-> 	GO데이터				---			json.Unmarshal()

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

XML		:		<Member>
				  <Name>Alex</Name>
				  <Age>10</Age>
				</Member>

import "encoding/xml"

인코딩		:		GO데이터 	-> 	XML			---			xml.Marchal(인코딩할 데이터)
디코딩		:		XML 	-> 	GO데이터			---			xml.Unmarshal(디코딩할 데이터, &집어넣을 구조체)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

트랜잭션		:		DB에서 여러 작업을 하나의 묶음으로 처리. 하나라도 에러나면 전체를 취소.

Begin()






========================================================================================================================================================================

## go + vue 로 todo 실습

1. vo 생성

Todo struct
AddTodo struct 
UpdateTodo struct

2. Repository 생성

TodoRepository struct
func NewTodoRepository()	

func Save()
func FindAll()
func FindByID()
func Update()
func Delete()

3. service 생성

TodoService struct
func NewTodoService()

func AddTodo()
func TodoList()
func TodoDetail()
func UpdateTodo()
func DeleteTodo()

4. handler 생성

func AddTodo()
func TodoList()
func TodoDetail()
func UpdateTodo()
func DeleteTodo()

5. main.go







































